#include <filesystem>
#include <fstream>

#include "sceneloader.h"
#include "component.h"

bool findLastScene(std::string* outScene) {
    std::string path = "../data/scenes/";

    if (!std::filesystem::exists(path) || !std::filesystem::is_directory(path)) {
        std::cerr << "ERROR::BAD_PATH::No directory found at: " << path << std::endl;
        return false;
    }

    for (const auto& file : std::filesystem::directory_iterator("../data/scenes/")) {
        if (std::filesystem::is_regular_file(file) && file.path().extension() == ".scene") {
            *outScene = file.path().string();
        }
    }

    return false;
}

void skipWhitespace(std::ifstream* stream) {
    while (std::isspace(stream->peek())) {
        stream->get();
    }
}

void findNextEndToken(std::ifstream* stream) {
    while (!stream->eof()) {
        char c = static_cast<char>(stream->peek());
        if (c == '}') {
            stream->get();
            skipWhitespace(stream);
            return;
        }

        stream->get();
    }
}

void getComponentBlock(std::ifstream* stream, std::vector<ComponentBlock>* components) {
    ComponentBlock block;
    skipWhitespace(stream);

    if (!std::isalpha(stream->peek())) {
        findNextEndToken(stream);
        if (stream->eof()) {
            return;
        }
    }

    char c = static_cast<char>(stream->peek());
    std::string typeString;

    while (c != '{') {
        c = stream->get();

        if (!std::isspace(c)) {
            typeString += stream->get();
        }

        c = static_cast<char>(stream->peek());
    }

    block.type = typeString;
    stream->get();
    skipWhitespace(stream);

    std::string memberName;
    std::string memberValue;

    std::string* current;
    current = &memberName;

    while (c != '}') {
        if (c == ':') {
            block.memberValueMap[memberName] = "";
            memberName = "";
            *current = memberValue;
        }

        skipWhitespace(stream);
        c = static_cast<char>(stream->peek());
    }
}

void getNextToken(std::ifstream* stream, std::vector<Token>* tokens) {
    char c = static_cast<char>(stream->get());

    std::string text;

    switch (c) {
        case '{':
            Token token;
            token.type = TokenType::BlockOpen;
            token.text = "{";
            tokens->push_back(token);
            break;
        case '}':
            Token token;
            token.type = TokenType::BlockClose;
            token.text = "}";
            tokens->push_back(token);
            break;
        case ':':
            Token token;
            token.type = TokenType::ValueSeparator;
            token.text = ":";
            tokens->push_back(token);
            break;
        default:
            if (!std::isalnum(stream->peek())) {
                std::cerr << "ERROR::UNKNOWN_TOKEN" << std::endl;
                return;
            }

            while (std::isalnum(c)) {
                text += static_cast<char>(stream->get());
            }

            Token token;
            token.type = TokenType::TypeName;
            token.text = text;
            tokens->push_back(token);
            break;
    }
}

void getTokens(std::ifstream* stream, std::vector<Token>* tokens) {
    skipWhitespace(stream);

    while (!std::isalpha(stream->peek())) {
        findNextEndToken(stream);
        if (stream->eof()) {
            std::cerr << "ERROR::Could not find first block" << std::endl;
            return;
        }
    }

    char c = static_cast<char>(stream->peek());

    while (!stream->eof()) {
        getNextToken(stream, tokens);

        c = static_cast<char>(stream->peek());
    }
}

Scene* loadScene(std::string path) {
    Scene* scene = new Scene();
    std::ifstream stream(path);
    std::vector<ComponentBlock> components;
    skipWhitespace(&stream);
    while (!stream.eof()) {
        getComponentBlock(&stream, &components);
        skipWhitespace(&stream);
    }

    return scene;
}
